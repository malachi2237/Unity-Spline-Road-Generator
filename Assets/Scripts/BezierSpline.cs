using System.Collections;
using System.Collections.Generic;
using UnityEngine;

/// <summary>
/// A class representing a composition of bezier curves. By default, the <c>BezierSpline</c> will fit cubic curves through
/// an input set of knots, 
/// </summary>
public class BezierSpline
{
    /// <summary>
    /// A list of the knots used to compose the spline
    /// </summary>
    private List<Vector3> _knots;

    /// <summary>
    /// A list of the control points used to compose a cubic spline, generated by <c>GenerateSmoothControlPoints</c>.
    /// </summary>
    /// <value> Control points between <c>_knots[n]</c> and <c>knots[n+1]</c> correspond to 
    /// <c>_generatedControlPoints[2n]</c> and <c>_generatedControlPoints[2n+1]</c>. A value of 
    /// <c>null</c> means control points were provided at initialization.</value>
    private List<Vector3> _generatedControlPoints = new List<Vector3>();

    /// <summary>
    /// A list of <c>BezierCurve</c>s representing the spline
    /// </summary>
    private List<BezierCurve> _curves;

    /// <summary>
    /// Initialize the spline with a series of knots. Cubic control points will be automatically generated.
    /// </summary>
    /// <param name="knots">A series of points representing knots</param>
    public BezierSpline(in ICollection<Vector3> knots, in int resolution = 100)
    {
        Debug.Assert(knots.Count > 1);

        _knots = new List<Vector3>(knots);
        _curves = new List<BezierCurve>(knots.Count - 1);

        var controlPoints = GenerateSmoothControlPoints();
        var curvePoints = new Vector3[4];

        for (int i = 0; i < _knots.Count - 1; i++)
        {
            curvePoints[0] = _knots[i];
            curvePoints[1] = controlPoints.first[i];
            curvePoints[2] = controlPoints.second[i];
            curvePoints[3] = _knots[i + 1];

            _curves.Add(new BezierCurve(curvePoints, resolution));

            _generatedControlPoints.Add(controlPoints.first[i]);
            _generatedControlPoints.Add(controlPoints.second[i]);
        }
    }

    public List<Vector3> GetControlPoints()
    {
        return new List<Vector3>(_generatedControlPoints);
    }

    public IList<BezierCurve> GetComposingCurves()
    {
        return new List<BezierCurve>(_curves);
    }

    /// <summary>
    /// Intialize the spline with a sequence of knots and control points.
    /// </summary>
    /// <param name="knots">A series of <c>n</c> points representing knots</param>
    /// <param name="controlPoints">A series of points representing control points between knots.
    /// Control points in <c>controlPoints[i]</c> will be the points between <c>knots[i]</c> and 
    /// <c>knots[i+1]</c>. As a result, <c>controlPoints</c> must contain at least n-1 elements. 
    /// elements past n-1 will be ignored. </param>
    public BezierSpline(in ICollection<Vector3> knots, in List<ICollection<Vector3>> controlPoints, in int resolution = 100)
    {
        Debug.Assert(knots.Count > 1);
        Debug.Assert(controlPoints.Count == (knots.Count - 1));

        _knots = new List<Vector3>(knots);
        _curves = new List<BezierCurve>(knots.Count - 1);

        for (int i = 0; i < knots.Count - 1; i++)
        {
            _curves.Add(new BezierCurve(_knots, controlPoints[i], resolution));
        }
    }


    /// <summary>
    /// Converts the spline into a discrete set of points and rotations.
    /// </summary>
    /// <returns>An <c>IList</c> of <c>DiscreteCurve</c>s representing all composing curves</returns>
    public IList<DiscreteCurve> CalculateDiscreteCurves(float angleLimit = 5.0f)
    {
        Debug.Assert(_curves != null, "Curves uninitialized");
        Debug.Assert(_curves.Count > 0, "Must have a non-zero amount of curves");

        return _curves.ConvertAll(curve => curve.GetOptimizedDiscreteCurve(angleLimit));
    }

    /// <summary>
    /// Converts part of the spline into a discrete set of points and rotations starting from <c>startKnot</c> to <c>endKnot</c>.
    /// </summary>
    /// <param name="startknot">Index of the first knot of the first curve to be converted</param>
    /// <param name="endKnot">Index of the last knot of the last curve to be converted</param>
    /// <returns>A set of <c>DiscreteCurve</c>s between <c>startKnot</c> and <c>endKnot</c></returns>
    public IList<DiscreteCurve> CalculateDiscreteCurves(in int startknot, in int endKnot)
    {
        Debug.Assert(_curves != null && _curves.Count > endKnot && startknot > 0);

        var dSpline = new List<DiscreteCurve>();

        for (int i = startknot; i < endKnot; i++)
            dSpline.Add(_curves[i].GetOptimizedDiscreteCurve());

        return dSpline;
    }

    /// <summary>
    /// Generates cubic control points guaranteed to smoothly fit the curve through <c>_knots</c>. 
    /// </summary>
    /// <returns> Tuple containing the arrays of the first and second control points between each knot </returns>
    private (Vector3[] first, Vector3[] second) GenerateSmoothControlPoints()
    {
        // Spline is actually just a single curve, should just be a straight line
        if (_knots.Count == 2)
            return (null, null);

        int n = _knots.Count - 1;
        var rightHandVectors = new Vector3[n];
        var secondControlPoints = new Vector3[n];

        Vector3[] firstControlPoints;
        

        // Calculate right hand values of the tridiagonal system
        rightHandVectors[0] = _knots[0] + 2 * _knots[1];

        for (int i = 1; i < n - 1; i++)
            rightHandVectors[i] = 4 * _knots[i] + 2 * _knots[i + 1];

        rightHandVectors[n - 1] = (8 * _knots[n - 1] + _knots[n]) / 2.0f;

        //firstControlPoints = SolveBezierTridiagonalSystem(ref rightHandVectors);
        firstControlPoints = GetFirstControlPoints(rightHandVectors);
        // calculate second control points from first
        for (int i = 0; i < n - 1; i++)
            secondControlPoints[i] = 2 * _knots[i + 1] - firstControlPoints[i + 1];

        secondControlPoints[n - 1] = (_knots[n] + firstControlPoints[n - 1]) / 2.0f;

        return (firstControlPoints, secondControlPoints);
    }

    /// <summary>
    /// Solves the spline's tridiagonal system via the <see href="https://en.wikipedia.org/wiki/Tridiagonal_matrix_algorithm">Thomas Algorithm</see>.
    /// See description of the matrix <see href="https://tinyurl.com/bddvdmmr">here</see>.
    /// </summary>
    /// <param name="d">Right hand side vectors of the system.</param>
    /// <returns>The first control points of a smoothened cubic spline</returns>
    private static Vector3[] SolveBezierTridiagonalSystem(ref Vector3[] d)
    {
        const int a = 1, c = 1, aSubN = 2, b = 4, bSubZero = 2, bSubN = 7;

        int n = d.Length;
        int w;
        var x = new Vector3[n];
        var bSubi = new int[n];

        // calculate 

        bSubi[0] = bSubZero;
        for (int i = 1; i < n - 1; i++)
        {
            w = a / b;
            bSubi[i] = b - w * c;
            d[i] = d[i] - w * d[i - 1];
            
        }

        w = aSubN / b;
        bSubi[n - 1] = bSubN - w * c;
        d[n - 1] = d[n - 1] - w * d[n - 2];

        //back subsitution
        x[n - 1] = d[n - 1] / bSubi[n - 1];

        for (int i = n - 2; i >= 0; i--)
            x[i] = (d[i] - c * x[i + 1]) / bSubi[i];

        return x;
    }

    private static Vector3[] GetFirstControlPoints(Vector3[] rhs)
    {
        int n = rhs.Length;
        Vector3[] x = new Vector3[n]; // Solution vector.
        float[] tmp = new float[n]; // Temp workspace.

        float b = 2.0f;
        x[0] = rhs[0] / b;
        for (int i = 1; i < n; i++) // Decomposition and forward substitution.
        {
            tmp[i] = 1 / b;
            b = (i < n - 1 ? 4.0f : 3.5f) - tmp[i];
            x[i] = (rhs[i] - x[i - 1]) / b;
        }
        for (int i = 1; i < n; i++)
            x[n - i - 1] -= tmp[n - i] * x[n - i]; // Backsubstitution.

        return x;
    }
}
